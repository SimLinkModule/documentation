%!TEX root = ../Studienarbeit.tex

\chapter{Rekapitulation und Ausblick}
\section{Rekapitulation}

Die für diese Arbeit notwendigen Aufgaben wurden in vier Bereiche aufgeteilt. Im ersten Teilbereich der Softwareentwicklung wurde die nötige Kommunikation zwischen der Multikopterfernsteuerung und dem Erweiterungsmodul implementiert. Als Kommunikationsprotokoll wird CRSF verwendet, da dies die höchste Übertragungsrate bei möglichst kleinen Datenpaketen, von allen vorhandenen Kommunikationsprotokollen der Fernsteuerung, bietet. Ebenso wurde die Kommunikation zwischen dem Erweiterungsmodul und den Endgeräten entwickelt. Als Kommunikationsprotokoll wird hierfür \ac{BLE} verwendet, indem die Fernsteuerungsdaten mittels \ac{HOGP} verpackt sind. Damit ein Endanwender mit dem Erweiterungsmodul interagieren kann, wurden zusätzlich Eingabemöglichkeiten durch Taster hinzugefügt. Für die Ausgabe von Statusinformationen wird ein \acs{OLED}-Display verwendet, welches für den Datenaustausch \ac{I2C} verwendet. Der zweite Teilbereich befasste sich mit dem Entwurf von Platinen für das Erweiterungsmodul. Dies war nötig damit das Erweiterungsmodul kompakt, mobil und benutzerfreundlich verwendet werden kann. Dafür sind final drei Platinen erstellt worden, welche alle Elektronikkomponenten enthalten, wie beispielsweise den ESP32-Mikrocontroller, das \acs{OLED}-Display, mehrere Eingabetaster, eine Spannungsregulierung und eine Buchse für die Verbindung mit der Multikopterfernsteuerung. Der dritte Teilbereich umfasste die Entwicklung eines Gehäuses, um die entworfenen Platinen fest und kompakt im Modulschacht (Typ: Lite) der Fernsteuerung befestigen zu können. Hierbei wurde darauf geachtet, dass das Gehäuse mittels eines \ac{FDM}-3D-Druckers gedruckt werden kann und eine möglichst geringe Nachbearbeitung benötigt. Der letzte Teilbereich befasste sich mit der Validierung des Funktionsumfangs und dem Latenzvergleich zwischen dem Erweiterungsmodul und der internen USB-Schnittstelle der Multikopterfernsteuerung. In der Validierung konnte festgestellt werden, das der größte Teil der ursprünglichen Anforderungen umgesetzt worden konnte. Jedoch konnte die Verwendung des Erweiterungsmoduls unter iOS- und iPadOS-Geräten nicht umgesetzt werden. Rein technisch ist diese Funktion umgesetzt, was durch die internen \ac{HCI}-Daten des Endgeräts nachgewiesen werden kann. Es stellte sich dabei heraus, dass das Erweiterungsmodul zusätzlich durch das \ac{MFi}-Programm von Apple zertifiziert werden müsste, was einen großen Kosten- und Arbeitsaufwand mit sich bringt. Im Latenzvergleich zwischen der internen USB-Verbindung der Fernsteuerung und der \ac{BLE}-Verbindung des Erweiterungsmoduls, konnte festgestellt werden, dass die Latenz der \ac{BLE}-Verbindung im Durchschnitt 20,84~ms größer ist (Optimalfall). Durchschnittlich beträgt nämlich die Latenz der \ac{BLE}-Verbindung 30~ms und hat eine Standardabweichung von 7,68~ms im Optimalfall. Zugehörig ist in Kapitel \ref{section:resultExplanation} beschrieben, wie der Optimalfall der \ac{BLE}-Verbindung definiert ist.

Hervorzuheben ist, dass die Latenz des \ac{BLE}-Erweiterungsmoduls wie beschrieben, im Vergleich zu der vorhandenen USB-Verbindung, angestiegen ist. Auch werden nur die nötigsten \ac{GAP}-Events durch das Erweiterungsmodul ausgewertet, wodurch hilfreiche Informationen vor dem Endnutzer verschwiegen werden. Zuletzt ist noch anzumerken, dass die Produktionskosten des Erweiterungsmoduls für die Eigenverwendung zu hoch ausfallen (ungefähr 180~€). Alternativ zur Produktion der Erweiterungsplatinen und dem 3D-Druck eines Gehäuses, kann auch das Erweiterungsmodul mit einem ESP32-Entwicklungsboard und wenigen weiteren Elektronikkomponenten nachgebaut werden. Hierdurch können die Kosten auf ungefähr 50~€ gesenkt werden. 

Zusammenfassend ist mit dem entwickelten Erweiterungsmodul nun möglich, modellunabhängig Multikopterfernsteuerungen mittels \ac{BLE} mit einem Endgerät zu verbinden. Einschränkungen hierbei sind, dass die Multikopterfernsteuerung das CRSF-Protokoll für die Übertragung am Modulschacht unterstützen muss und dass das Betriebssystem des Endgeräts Windows, Linux oder Android sein muss. Die Software, der Platinenentwurf sowie das Gehäusedesign werden unter der open source Lizenz \textit{Apache-2.0} öffentlich zugänglich bereitgestellt.

\section{Ausblick}
Aufbauend auf den Ergebnissen dieser Arbeit, können weitere Anpassungen in den Bereichen Platinenentwurf, Gehäuseentwurf und Softwareentwicklung durchgeführt werden.

Im Bereich des Platinenentwurfs können Anpassungen erfolgen, um die Platinen kleiner und kompakter gestalten zu können. Dafür kann zum einen die Verbindungsplatine zwischen der Multikopterfernsteuerung und dem Erweiterungsmodul in die Hauptplatine des Erweiterungsmoduls integriert werden. Zum anderen kann die Logik für die Programmierung des ESP32-Mikrocontroller entfallen, da diese Logik nur selten benötigt wird und der Start des Mikrocontrollers in den Programmiermodus auch manuell durchgeführt werden kann (siehe Kapitel \ref{section:pcbImplementation}). Zusätzlich kann die Platinengröße verringert werden, indem die benötigten Elektronikkomponenten beidseitig auf den Platinen angebracht werden.

Im Bereich des Gehäuseentwurfs kann einerseits ein Adapter konstruiert werden, um das Erweiterungsmodul (Typ: Lite) für Modulschächte mit einer Standardgröße vorzubereiten. Zusätzlich wird hierfür eine Adapterplatine benötigt, welche das Buchsenlayout der verschiedenen Modulschachtarten adaptiert. Andererseits können durch die erwähnten Platinenanpassungen das Gehäuse kompakter gestaltet werden, wodurch das \acs{OLED}-Display für eine bessere Lesbarkeit näher an der Gehäuseaußenkante angebracht werden kann.

Im Bereich der Softwareentwicklung kann die Auswertung der verfügbaren \ac{GAP}-Events implementiert werden, um Benutzern des Erweiterungsmoduls weiterführende Informationen anzubieten. Ebenso können weitere Kommunikationsprotokolle zwischen der Multikopterfernsteuerung und dem Erweiterungsmodul implementiert werden, um weitere Fernsteuerungsmodelle zu unterstützen. Dabei ist die Implementierung von digitalen Kommunikationsprotokollen ohne Hardwareanpassungen möglich. Während für die Implementierung von analogen Kommunikationsprotokollen zusätzlich der analoge Pin des Modulschachts mit dem ESP32-Mikrocontroller verbunden werden muss.