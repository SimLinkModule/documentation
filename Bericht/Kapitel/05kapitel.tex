%!TEX root = ../Studienarbeit.tex

\chapter{Validierung und Gegenüberstellung}
\todo[inline]{Ab hier überarbeiten}
\section{Validierung des Funktionsumfangs}

In diesen Abschnitt der Studienarbeit soll der in Kapitel \ref{section:Aufgabenstellung} definierte Aufgabenumfang mit dem realisierten Umfang verglichen werden und gegebenenfalls die vorhandenen Einschränkungen erläutert werden.

\subsection{Softwareentwicklung}
Die Anforderungen an die Software des Erweiterungsmoduls sind in Kapitel \ref{section:softwareRequirement} aufgelistet und werden nacheinander in diesem Unterkapitel mit der finalen Umsetzung verglichen.

Die erste Anforderung ist die Unterstützung der Kommunikation des Erweiterungsmoduls mit Endgeräten auf denen das Betriebssystem Android, Windows, Linux oder iOS/iPadOS vorhanden ist. Getestet wurde das Erweiterungsmodul mit allen genannten Betriebssystemen mit jeweils einer Betriebssystemveriosn und einer Simulatorsoftware auf dem jeweiligen Betriebssystem. Getestet wurde das Erweiterungsmodul unter Android Version 10 und der Simulatorsoftware \textit{FPV.SkyDive}, dabei konnte der vollständige Funktionsumfang nachgewiesen werden. Unter Windows 11 mit der Simulatorsoftware \textit{Velocidrone} konnte ebenso der vollständige Funktionsumfang des Erweiterungsmoduls nachgewiesen werden. Als Linux-Betriebssystem wurde \textit{Pop! OS 22.04 LTS} mit der Simulatorsoftware \textit{Velocidrone} verwendet. Dort konnte gleichermaßen der vollständige Funktionsumfang nachgewiesen werden. Für die Überprüfung des Funktionsumfangs des Erweiterungsmoduls mit iOS/iPadOS 16.3.1 wurde die Simulatorsoftware \textit{FPV.SkyDive} verwendet. Dort konnte keine Funktionsfähigkeit nachgewiesen werden. Jedoch findet unter iOS/iPadOS ein Verbindungsaufbau zwischen dem Erweiterungsmodul und dem iOS/iPadOS-Endgerät statt und ebenfalls werden die Daten vom Erweiterungsmodul iOS/iPadOS-Endgerät empfangen. Nachgewiesen werden kann dies mit der Software \textit{packetLogger} und \textit{libimobiledevice}. Für weitere Untersuchungen wurde ein, mit iOS/iPadOS kompatibler, Nintendo Switch-Controller herangezogen und der Kommunikationsaustausch zwischen dem iOS/iPadOS-Endgerät und dem Nintendo Switch-Controller betrachtet. Dabei stellt sich heraus, dass der Nintendo Switch-Controller mittels \ac{BBR} die Gamecontrollerdaten und nicht mittels \ac{BLE} übertragt. Wie in Quelle \cite{lemmingDevESP32Comment} beschrieben ist, müssen \ac{BLE}-Gamecontroller durch das \ac{MFi}-Programm zertifiziert werden und ein zusätzliches Hardwaremodul enthalten, entgegen der ursprünglichen Annahme, welche in Kapitel \ref{section:appleAnforderungen} beschrieben ist.

Die zweite Anforderung an die Software ist, dass die Kommunikation zwischen dem Erweiterungsmodul und den Endgeräten mittels \ac{BLE} erfolgen und sich das Erweiterungsmodul als \ac{HID}-Gerät authentifizieren soll. Die Umsetzung dieser Anforderung ist in Kapitel \ref{section:bluetoothStackSelection} und \ref{section:communicationModuleDevice} beschrieben.

Die dritte Anforderung ist, dass die Kommunikation zwischen dem Erweiterungsmodul und der Multikopterfernsteuerung über den Modulschacht der Fernsteuerung erfolgen soll. Auch soll die Kommunikation mittels eines vorhandenen Protokolls der Fernsteuerungsfirmware OpenTX oder einer Abspaltung davon erfolgen. Als Kommunikationsprotokoll zwischen dem Erweiterungsmodul und der Multikopterfernsteuerung wird CRSF verwendet wie in Kapitel \ref{section:communicationCRSF} nachgelesen werden kann. Getestet wurde die Erweiterungsmodulsoftware mit der Multikopterfernsteuerung Tango 2 von dem Unternehmen \textit{Team Blacksheep} mit der Firmware FreedomTX Version TBS-1.3.0. Dabei kann festgestellt werden, dass alle versendeten Kanaldaten mittels dem CRSF-Protokoll empfangen und verarbeitet werden können.

Die vierte Anforderung ist, dass es verschiedene Ein- und Ausgabemöglichkeiten geben soll für die Interaktion mit dem Erweiterungsmodul durch den Endanwender des Erweiterungsmoduls. Dafür wird einerseits für die Ausgabe von Statusnachrichten ein \acs{OLED}-Display verwendet, wie in Kapitel \ref{section:oledOutput} beschrieben ist. Andererseits gibt es Taster für Eingaben durch den Endanwender, nachzulesen in Kapitel \ref{section:softwareCombination}. Ebenfalls war ein Teil dieser Anforderung, dass weitere Statusindikatoren als \acp{LED} integriert werden sollen. Dies ist jedoch nicht umgesetzt worden, da alle wichtigen Statusnachrichten für den Endanwender durch das \acs{OLED}-Display angezeigt werden können. Lediglich eine Status-\ac{LED} ist vorhanden, um anzuzeigen, ob eine funktionierende Stromzufuhr zum Erweiterungsmodul vorhanden ist. Dies ist jedoch komplett in Hardware realisiert wie in Abbildung \ref{fig:spannungsRegulierung} zu sehen ist.


Die letzte Anforderung an die Software ist, dass der Akkustand der Multikopterfernsteuerung an das zugehörige Endgerät übermittelt wird. Die Softwarekomponente hierfür ist vollständig vorhanden und funktionsfähig, jedoch bietet der Lite-Modulschachtstecker keinen Pin, an dem die rohe Akkuspannung anliegt (zu sehen in Abbildung \ref{fig:pinoutController}). Aus diesem Grund wird im \ac{BLE}-Akkustand-Merkmal immer der Wert 0 übertragen. Dadurch wird sichergestellt, dass der Endanwender des Erweiterungsmoduls selbst den aktuellen Akkustand der Multikopterfernsteuerung überprüft, da er davon ausgehen kann das es sich um ein Fehlverhalten des Erweiterungsmoduls handelt.

\subsection{Platinenentwurf}
Die Anforderungen an die entworfenen Platinen des Erweiterungsmoduls sind in Kapitel \ref{section:pcbRequirement} aufgelistet. Dabei ist die Hauptanforderung, dass die Platine alle benötigten Elektronikkomponenten für das Erweiterungsmodul, welche im prototypischen Steckbrettaufbau vorhanden sind, enthalten muss. Zusätzlich sollte die Platine möglichst kompakt sein, damit die Platine an der Multikopterfernsteuerung verwendet werden kann, ohne dass diese während der Verwendung der Fernsteuerung stört. Diese Anforderungen wurden in den Platinen, welche in Kapitel \ref{section:pcbImplementation} vorgestellt wurden, umgesetzt. Die Platine enthält dafür den ESP32-Mikrocontroller, die benötigte Spannungsregulierung für alle Elektronikkomponenten sowie Taster, ein Display und eine Status-\ac{LED} für die Interaktion mit dem Endanwender. Zusätzlich ist ein \ac{ESD}-Schutz an der Erweiterungsmodulbuchse integriert, ebenso wie weitere Komponenten für die komfortablere Programmierung des ESP32-Mikrocontrollers.

\subsection{Gehäuseerstellung}
Die Anforderungen an das Erweiterungsmodulgehäuse sind in Kapitel \ref{section:caseRequirement} aufgelistet und umfassen den Entwurf eines Kunststoffgehäuses, welches für Modulschächte des Typs \textit{Lite} ist und möglichst ohne Nachbearbeitung verwendet werden kann. All diese Anforderungen sind im entworfenen Gehäuse von Kapitel \ref{section:caseImplementation} realisiert worden. Das entworfene Gehäuse ist für Erweiterungsmodulschächte des Typs \textit{Lite} und kann mit vier Stützstrukturen gedruckt werden. Da diese an nicht sichtbaren Bereichen des Gehäuses benötigt werden, entfällt die Nachbearbeitung der Oberflächen.

\section{Gegenüberstellung \acs{BLE}-Modul und USB-Verbindung}
Ein wichtiges Merkmal von Fernsteuerung während der Verwendung im Simulator als auch mit einem reellen Multikopter stellt die Latenz zwischen der Eingabe eines Signals bis zur Verarbeitung an der Gegenstelle dar. Um die Latenz zu bestimmen wird der nachfolgend beschriebene Versuchsaufbau verwendet.

\subsection{Versuchsaufbau}
%Test zunächst mit servo probiert, um nicht an Platine direkt arbeiten zu müssen. Jedoch ist der Delay nicht in einen glaubwürdigen bereich, da zu lang.
%Eine Studie gefunden, bei dem optokoppler verwendet wurden, und verschiedene Geräte getestet wurde als vergleichswert verwendbar.
%Dadurch neuer Versuchsaufbau mit optokoppler. Schauen ob es in einen bereich mit den restlichen ist und wie viel schlechter es wurde.
%Schreiben das mit evdev ermittelt wird und welche latenzen im System vorhanden sind --> Bild dafür hinzufügen

%Bild von alter Haltung mit dem Servo zeigen
%Bild von der Schaltung noch machen in KiCad

\subsection{Auswertung}
%Vielleicht gaußverteilung darstellen und werte dafür raussrechnen. Schreiben dass x mal getestet wurde.
%Vergleich mit der anderen arbeit aus regensburg gegenüberstellen.
%Berechnen was für eine Strecke geflogen wird in 30ms. Geschwindigkeit von Renndrohnen und normalen drohnen ausrechnen. Dabei jedoch schreiben, dass es in relation gesehen werden muss, dass pro neuen Signal nur immer von relativen Anpassungen der Flugbahn ausgegangen werden muss und nicht von 
%Auch noch schreiben, dass die Testperson (ein Hobbiedrohnenpilot) keinen merkbaren unterschied zwischen einer USB-Verbindung und BLE-Verbindung ausmachen konnte im Simulator.
%Schreiben wieso diese zusätzliche Latenz zu stande kommt und die ausreißer.
    %-nicht jedes CRSF für die Tastenstellungen
    %-Übertragungsrate von BLE
    %-Doppelte Umwandlung in verschiedene Protokolle
%auch sollten die einzelnen ausgefallenen Pakete oder die nach 100ms nicht all zu fehlerbehaftet gesehen werden, da sich ständig werte ändern während der flug einer drohne und nicht nur ein einziges signal sich ändert wodurch viel häufiger die alle Controller-Daten an das Endgerät gesendet werden
%schreiben wieso es so spikes an gewissen stellen gibt
    %-Ist von der Pollingrate von BLE und USB abhängig